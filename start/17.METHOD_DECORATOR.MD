Absolutely! Let’s deep dive into **method decorators** in TypeScript, their mechanics, and **real-world uses**. I’ll break it down clearly.

---

## 1️⃣ **What is a Method Decorator?**

A **method decorator** is a function applied to a **class method**.
It receives three parameters:

```ts
target      // The class prototype (for instance methods) or constructor (for static methods)
propertyKey // Name of the method
descriptor  // PropertyDescriptor of the method
```

You can use it to **modify the method behavior**, log, validate, or add metadata.

---

## 2️⃣ **Basic Syntax**

```ts
function LogMethod(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
) {
  const original = descriptor.value; // save the original method

  descriptor.value = function (...args: any[]) {
    console.log(`Called ${propertyKey} with`, args);
    const result = original.apply(this, args); // call original
    console.log(`Result:`, result);
    return result;
  };
}

class Calculator {
  @LogMethod
  add(a: number, b: number) {
    return a + b;
  }
}

const calc = new Calculator();
calc.add(2, 3);
// Logs:
// Called add with [2, 3]
// Result: 5
```

✅ Here, we **wrapped the original method** to log inputs and outputs.

---

## 3️⃣ **Common Uses of Method Decorators**

### a) **Logging / Debugging**

Automatically log method calls, arguments, and results.

```ts
@LogMethod
updateUser(id: number, name: string) {
  // update logic
  return true;
}
```

### b) **Access Control / Authorization**

Check user roles before running a method.

```ts
function Authorized(roles: string[]) {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const original = descriptor.value;
    descriptor.value = function (...args: any[]) {
      const userRole = (this as any).role;
      if (!roles.includes(userRole)) {
        throw new Error("Unauthorized");
      }
      return original.apply(this, args);
    };
  };
}

class AdminActions {
  role = "user";

  @Authorized(["admin"])
  deleteUser() {
    console.log("User deleted");
  }
}

const admin = new AdminActions();
admin.deleteUser(); // ❌ Error: Unauthorized
```

### c) **Caching / Memoization**

Store results to avoid expensive repeated calculations.

```ts
function Memoize(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const original = descriptor.value;
  const cache = new Map<string, any>();

  descriptor.value = function (...args: any[]) {
    const key = JSON.stringify(args);
    if (cache.has(key)) return cache.get(key);
    const result = original.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

class Fibonacci {
  @Memoize
  fib(n: number): number {
    if (n <= 1) return n;
    return this.fib(n - 1) + this.fib(n - 2);
  }
}

const fib = new Fibonacci();
console.log(fib.fib(10)); // calculated and cached
console.log(fib.fib(10)); // returned from cache
```

### d) **Error Handling / Retry**

Automatically retry failed method calls.

```ts
function Retry(times: number) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      for (let i = 0; i < times; i++) {
        try {
          return await original.apply(this, args);
        } catch (err) {
          console.log(`Retry ${i + 1} failed`);
        }
      }
      throw new Error("All retries failed");
    };
  };
}

class API {
  counter = 0;

  @Retry(3)
  async fetchData() {
    this.counter++;
    if (this.counter < 3) throw new Error("Fail");
    return "Success";
  }
}

const api = new API();
api.fetchData().then(console.log); // Logs retries and eventually Success
```

---

## 4️⃣ **Key Points to Remember**

* A method decorator **can override the method** by modifying `descriptor.value`.
* You can **wrap**, **replace**, or **enhance** method behavior.
* Can be **combined with other decorators** (class/property/parameter).
* Works well for **cross-cutting concerns** like logging, caching, authorization, or retries.

---
Ah! You’re asking about the **parameters of a method decorator** in TypeScript: `target`, `propertyKey`, and `descriptor`. Let’s go **step by step** and make it very clear.

---

## **1️⃣ Method Decorator Signature**

A **method decorator** in TypeScript looks like this:

```ts
function MyMethodDecorator(
    target: Object,          // 1
    propertyKey: string | symbol,  // 2
    descriptor: PropertyDescriptor  // 3
) {
    // decorator logic
}
```

* It is applied like:

```ts
class Example {
    @MyMethodDecorator
    sayHello() {
        console.log("Hello");
    }
}
```

---

## **2️⃣ Parameter 1: `target`**

* **What it is:**

  * For **instance methods**, `target` is the **prototype** of the class.
  * For **static methods**, `target` is the **constructor function** of the class.

Example:

```ts
class Example {
    @MyMethodDecorator
    greet() {}
}

function MyMethodDecorator(target: any) {
    console.log(target); // Example.prototype
}
```

* If the method is **static**:

```ts
class Example {
    @MyMethodDecorator
    static greet() {}
}

// target will be Example (the constructor)
```

---

## **3️⃣ Parameter 2: `propertyKey`**

* **What it is:**

  * The **name of the method** as a string or symbol.
* Example:

```ts
function MyMethodDecorator(target: any, propertyKey: string) {
    console.log(propertyKey);
}

class Example {
    @MyMethodDecorator
    greet() {}   // logs "greet"
}
```

* Useful when you want to **wrap or modify a specific method**.

---

## **4️⃣ Parameter 3: `descriptor`**

* **What it is:** The **PropertyDescriptor** of the method.
* `PropertyDescriptor` contains information about the property/method:

```ts
{
    value: Function,      // The actual method
    writable: boolean,    // Can the method be overwritten
    enumerable: boolean,  // Is it enumerable in for..in
    configurable: boolean // Can descriptor be changed
}
```

* Example: Modify the method:

```ts
function LogMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
        console.log(`Calling ${propertyKey} with args:`, args);
        return originalMethod.apply(this, args);
    };
}

class Example {
    @LogMethod
    greet(name: string) {
        console.log(`Hello ${name}`);
    }
}

const e = new Example();
e.greet("Alice");
```

### Output:

```
Calling greet with args: ["Alice"]
Hello Alice
```

✅ What happened:

* `descriptor.value` was the original method (`greet`).
* We **overwrote it** with a wrapper function that logs before calling the original.

---

### **5️⃣ Summary Table**

| Parameter     | Instance Method    | Static Method      | Purpose                                |
| ------------- | ------------------ | ------------------ | -------------------------------------- |
| `target`      | Class prototype    | Class constructor  | Where the method lives                 |
| `propertyKey` | Method name        | Method name        | Name of the method being decorated     |
| `descriptor`  | PropertyDescriptor | PropertyDescriptor | Lets you **wrap or modify the method** |

---




