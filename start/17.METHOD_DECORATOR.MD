Absolutely! Let’s deep dive into **method decorators** in TypeScript, their mechanics, and **real-world uses**. I’ll break it down clearly.

---

## 1️⃣ **What is a Method Decorator?**

A **method decorator** is a function applied to a **class method**.
It receives three parameters:

```ts
target      // The class prototype (for instance methods) or constructor (for static methods)
propertyKey // Name of the method
descriptor  // PropertyDescriptor of the method
```

You can use it to **modify the method behavior**, log, validate, or add metadata.

---

## 2️⃣ **Basic Syntax**

```ts
function LogMethod(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
) {
  const original = descriptor.value; // save the original method

  descriptor.value = function (...args: any[]) {
    console.log(`Called ${propertyKey} with`, args);
    const result = original.apply(this, args); // call original
    console.log(`Result:`, result);
    return result;
  };
}

class Calculator {
  @LogMethod
  add(a: number, b: number) {
    return a + b;
  }
}

const calc = new Calculator();
calc.add(2, 3);
// Logs:
// Called add with [2, 3]
// Result: 5
```

✅ Here, we **wrapped the original method** to log inputs and outputs.

---

## 3️⃣ **Common Uses of Method Decorators**

### a) **Logging / Debugging**

Automatically log method calls, arguments, and results.

```ts
@LogMethod
updateUser(id: number, name: string) {
  // update logic
  return true;
}
```

### b) **Access Control / Authorization**

Check user roles before running a method.

```ts
function Authorized(roles: string[]) {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const original = descriptor.value;
    descriptor.value = function (...args: any[]) {
      const userRole = (this as any).role;
      if (!roles.includes(userRole)) {
        throw new Error("Unauthorized");
      }
      return original.apply(this, args);
    };
  };
}

class AdminActions {
  role = "user";

  @Authorized(["admin"])
  deleteUser() {
    console.log("User deleted");
  }
}

const admin = new AdminActions();
admin.deleteUser(); // ❌ Error: Unauthorized
```

### c) **Caching / Memoization**

Store results to avoid expensive repeated calculations.

```ts
function Memoize(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const original = descriptor.value;
  const cache = new Map<string, any>();

  descriptor.value = function (...args: any[]) {
    const key = JSON.stringify(args);
    if (cache.has(key)) return cache.get(key);
    const result = original.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

class Fibonacci {
  @Memoize
  fib(n: number): number {
    if (n <= 1) return n;
    return this.fib(n - 1) + this.fib(n - 2);
  }
}

const fib = new Fibonacci();
console.log(fib.fib(10)); // calculated and cached
console.log(fib.fib(10)); // returned from cache
```

### d) **Error Handling / Retry**

Automatically retry failed method calls.

```ts
function Retry(times: number) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      for (let i = 0; i < times; i++) {
        try {
          return await original.apply(this, args);
        } catch (err) {
          console.log(`Retry ${i + 1} failed`);
        }
      }
      throw new Error("All retries failed");
    };
  };
}

class API {
  counter = 0;

  @Retry(3)
  async fetchData() {
    this.counter++;
    if (this.counter < 3) throw new Error("Fail");
    return "Success";
  }
}

const api = new API();
api.fetchData().then(console.log); // Logs retries and eventually Success
```

---

## 4️⃣ **Key Points to Remember**

* A method decorator **can override the method** by modifying `descriptor.value`.
* You can **wrap**, **replace**, or **enhance** method behavior.
* Can be **combined with other decorators** (class/property/parameter).
* Works well for **cross-cutting concerns** like logging, caching, authorization, or retries.

---


